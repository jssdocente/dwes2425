# Entendiendo los Enumerados en PHP

Como desarrollador, seguramente te habr√°s encontrado con situaciones en las que una variable solo pod√≠a tomar uno de un peque√±o conjunto de valores posibles. Por ejemplo, una variable que contiene el estado de un usuario puede tener solo las posibilidades "Activo", "Inactivo" o "Suspendido". Puedes representar estos estados usando variables booleanas independientes o asignarles valores enteros o de cadena espec√≠ficos, pero ah√≠ es donde las cosas empiezan a complicarse y a generar errores.

¬øNo ser√≠a bueno tener una forma de declarar este conjunto restringido de valores posibles de una manera clara y autodocumentada? Ah√≠ es exactamente donde las enumeraciones, o Enums, como se las suele llamar, vienen al rescate.

Las enumeraciones han sido parte de muchos lenguajes de programaci√≥n durante a√±os y ¬°me dieron mucha envidia! Permiten definir un tipo que est√° restringido a un conjunto espec√≠fico de valores, lo que mejora tanto la claridad como la seguridad. Para los desarrolladores de PHP, la gran noticia es que a partir de PHP 8.1, las enumeraciones ahora son parte del n√∫cleo de PHP. S√≠, ¬°lo escuchaste bien! PHP ahora ofrece soporte integrado para enumeraciones. üéâ

### Una breve historia de las enumeraciones en PHP

Antes de PHP 8.1, PHP no ten√≠a compatibilidad integrada con enumeraciones. Si bien esta falta de enumeraciones no imped√≠a que los desarrolladores escribieran c√≥digo, s√≠ significaba que PHP carec√≠a de una herramienta que se encuentra en muchos otros lenguajes y que puede hacer que la codificaci√≥n sea m√°s segura y eficiente.

Sin enumeraciones integradas, los desarrolladores tuvieron que usar otras construcciones para representar un conjunto de valores posibles, recurriendo a menudo a constantes de clase, matrices o, a veces, simplemente cadenas o n√∫meros enteros.

Sin embargo, esto podr√≠a dar lugar a posibles errores y a menudo dar como resultado un c√≥digo que no era tan claro como podr√≠a ser.

La introducci√≥n de enumeraciones en PHP 8.1 ha sido una adici√≥n significativa al lenguaje.

La implementaci√≥n de enumeraciones en PHP es m√°s poderosa que la de muchos otros lenguajes, ya que las enumeraciones en PHP no son simplemente valores enteros o de cadena bajo el cap√≥.

En PHP, una enumeraci√≥n es un tipo especial de objeto, y los casos en que la enumeraci√≥n es un objeto de instancia √∫nica de esa clase.

Esto significa que puedes usar enumeraciones en cualquier lugar donde puedas usar un objeto, lo que las hace extremadamente vers√°tiles.

La adici√≥n de enumeraciones a PHP significa la evoluci√≥n continua del lenguaje para incorporar conceptos y paradigmas de programaci√≥n m√°s modernos, aumentando su eficiencia y permitiendo a los desarrolladores escribir c√≥digo m√°s limpio y seguro.

### Conceptos b√°sicos de los enumerados en PHP

Para desentra√±ar los conceptos b√°sicos de las enumeraciones en PHP, decid√≠ utilizar el mundo m√°gico de Harry Potter.

Imaginemos que estamos programando para el Colegio Hogwarts de Magia y Hechicer√≠a, donde cada nuevo estudiante debe ser asignado a una casa por el Sombrero Seleccionador virtual.

En Hogwarts solo hay cuatro casas: Gryffindor, Hufflepuff, Ravenclaw y Slytherin.

Entonces, podr√≠amos representar esto como una enumeraci√≥n en PHP.

As√≠ es como se declara una enumeraci√≥n:
  
```php
enum House
{
    case Gryffindor;
    case Hufflepuff;
    case Ravenclaw;
    case Slytherin;
}
```

En este ejemplo, `House` es el nombre de la enumeraci√≥n, y `Gryffindor`, `Hufflepuff`, `Ravenclaw` y `Slytherin` son los casos posibles de la enumeraci√≥n.

Vamos a crear una Studentclase donde cada estudiante posee una `$house` propiedad.
  
```php
class Student
{
    public ?House $house = null;
}
```

Tambi√©n tenemos una SortingHatclase con un sortm√©todo.

Este m√©todo acepta una sugerencia de casa o asigna una casa al azar al estudiante.

¬°Al igual que en Harry Potter, el Sombrero Seleccionador tom√≥ en cuenta la elecci√≥n de Harry!

```php
class SortingHat
{   
    public function sort(Student $student, ?House $suggestedHouse = null)
    {
        if ($suggestedHouse) {
            $student->house = $suggestedHouse;
            
            return;
        }

        $houses = [
            House::Gryffindor,
            House::Hufflepuff,
            House::Ravenclaw,
            House::Slytherin,
        ];

        $index = array_rand($houses);
        
        $student->house = $houses[$index];
    }
}
```
Como puedes ver, hemos limitado los valores de la `$suggestedHouse` variable y `$house` la propiedad para que solo sean una de las cuatro casas de Hogwarts que usan la Houseenumeraci√≥n, si por el contrario ese tipo fuera `string` o `int` podr√≠amos asignar cualquier valor, con el riesgo de que no sea una casa de Hogwarts üò¢.

Si intentara clasificar a un estudiante en una casa inexistente, PHP lo detectar√≠a y no se ejecutar√≠a.

¬°√âsa es la magia de las enumeraciones!

En este escenario, las casas de Hogwarts sin datos asociados se denominan ‚ÄúCasos Puros‚Äù, y una enumeraci√≥n que contiene solo Casos Puros, como nuestra Enumeraci√≥n de Casas, se denomina ‚ÄúEnumeraci√≥n Pura‚Äù.

### Emumerados puros frente a Enumerados con datos asociados

Las enumeraciones con datos asociados por un valor escalar. Por eso se las considera "no puras".

A modo de recordatorio, un valor escalar en PHP es de tipo bool, float, into string.

Un ejemplo:

```php	
<?php

enum House: string
{
    case Gryffindor = 'Gryffindor';
    case Hufflepuff = 'Hufflepuff';
    case Ravenclaw = 'Ravenclaw';
    case Slytherin = 'Slytherin';
}
```
Como puede ver, definimos el tipo que `respalda` la enumeraci√≥n  string en ese caso) y asignamos un valor a cada caso. No podr√≠a ser m√°s simple que eso. Pero, ¬øpor qu√© usar√≠a enumeraciones con tipo de datos asociado?

He aqu√≠ un gran caso de uso:

```php
$house = 'Gryffindor';

$student = new Student(
    House::from($house)
);

var_dump($student);
// object(Student) {
//   ["house"]=>
//   enum(House::Gryffindor)
// }
```

En este ejemplo:

1. Pretendemos que hemos obtenido datos de una base de datos e intentamos crear un nuevo `Student` objeto.
2. Inicializamos la `$house` propiedad con el `House::from()` m√©todo est√°tico a partir de un valor de cadena (ya que House ahora es una enumeraci√≥n respaldada de tipo string).
3. Si esto falla, se lanza una excepci√≥n. (*Uncaught ValueError: "XXX" is not a valid backing value for enum "House"*)

En algunos casos, en lugar de generar una excepci√≥n, es posible que desees recurrir a un valor predeterminado. Aqu√≠ te mostramos c√≥mo puedes hacerlo con el `House::tryFrom()` m√©todo est√°tico, que retorna nullen caso de falla.

```php
$student = new Student(
    House::tryFrom('Slytherin') ?? House::Gryffindor
);
```

### Listando valores de un Enumerado

En el ejemplo anterior se vi√≥ que sin sugerencia del estudiante se asigna una casa al azar.

Sin embargo, lo que me molesta del ejemplo que proporcion√© es que enumeramos manualmente los posibles valores de HouseEnum para construir nuestra matriz.

¬°Afortunadamente, todas las enumeraciones tienen un cases() m√©todo que puede hacer que nuestro c√≥digo sea m√°s flexible!

```php	
class SortingHat
{   
    public function sort(Student $student, ?House $suggestedHouse = null)
    {
        if ($suggestedHouse) {
            $student->house = $suggestedHouse;
            
            return;
        }

	    //Aqui tenemos que construir la matriz de valores posibles de la enumeraci√≥n, pero no es necesario enumerarlos manualmente
      $houses = [
          House::Gryffindor,
          House::Hufflepuff,
          House::Ravenclaw,
          House::Slytherin,
      ];

      //Con el m√©todo cases() podemos obtener los valores posibles de la enumeraci√≥n
	    $houses = House::cases();

      $index = array_rand($houses);
      $student->house = $houses[$index];
    }
}
```
Bastante ordenado, ¬øverdad?


### Un vistazo m√°s profundo a las enumeraciones en PHP y su comparaci√≥n con clases

En nuestro viaje con PHP Enums hasta ahora, es posible que hayas notado que son similares a las clases.

Pueden tener espacios de nombres, implementar `interfaces`, usar `traits` y tambi√©n se pueden cargar autom√°ticamente de la misma manera.

Pero, por supuesto, tambi√©n existen algunas diferencias significativas entre las clases PHP y las enumeraciones.

Repasemos nuestro ejemplo m√°gico de Harry Potter para entender estas diferencias.

Cuando el `Sombrero Seleccionador` asigna a un estudiante a una casa, sabemos que la casa siempre ser√° una de las cuatro opciones predefinidas: `Gryffindor, Hufflepuff, Ravenclawo Slytherin`.

No existen otras posibilidades en el contexto de Hogwarts. Este escenario es perfecto para las enumeraciones.

Una enumeraci√≥n, como House, es un tipo de datos √∫nico que comprende un conjunto de constantes predefinidas.

Significa que una variable s√≥lo puede tener una de estas constantes predefinidas y nada m√°s.

Por ejemplo, la `$house` propiedad de la `Student` clase solo puede contener una de las cuatro opciones de casa definidas en la *House* enumeraci√≥n.

```php
class Student
{
    public ?House $house = null;
}
```

Por el contrario, las clases en PHP, como nuestra *Student* clase, pueden contener una variedad de propiedades diferentes y pueden instanciarse varias veces con diferentes valores de propiedad.

Las enumeraciones, por otro lado, no se pueden instanciar y se utilizan para definir un conjunto fijo y limitado de instancias.

Otra diferencia est√° en la forma en que comparamos clases y enumeraciones.

En PHP, las enumeraciones se comparan por su identidad, no por sus valores.

Veamos un ejemplo:

```php
$a = House::Gryffindor;
$b = House::Gryffindor;

var_dump($a === $b); // bool(true)
```

En este ejemplo, `$a` y `$b` son la misma House instancia de Enum, por lo que tambi√©n `$a === $b` lo es true.

Las comparaciones que utilizan operadores menor que `<` o mayor que `>` no son significativas para los objetos Enum y siempre devolver√°n falso.

Los casos de enumeraci√≥n en PHP tienen una propiedad especial llamada `name`, que es el nombre del caso en s√≠, que distingue entre may√∫sculas y min√∫sculas. Esto puede resultar √∫til cuando se desea imprimir el nombre del caso de enumeraci√≥n.

```php
echo House::Gryffindor->name; // Prints "Gryffindor".
```

### Trabajar con m√©todos de enumeraci√≥n

Ahora que hemos explorado c√≥mo se pueden comparar las enumeraciones y sus diferencias con las clases, es hora de profundizar y explorar los m√©todos de enumeraci√≥n en enumeraciones PHP.

Al igual que las clases, las enumeraciones en PHP pueden contener m√©todos.

Veamos c√≥mo podemos utilizar esta funci√≥n utilizando nuestro escenario de clasificaci√≥n de Harry Potter.

```php
enum House
{
    case Gryffindor;
    case Hufflepuff;
    case Ravenclaw;
    case Slytherin;

    public function getHouseColors() : array
    {
        return match($this) {
            House::Gryffindor => ['Red', 'Gold'],
            House::Hufflepuff => ['Yellow', 'Black'],
            House::Ravenclaw => ['Blue', 'Bronze'],
            House::Slytherin => ['Green', 'Silver'],
        };
    }
}

var_dump(House::Gryffindor->getHouseColors());
// array(2) {
//   [0]=>
//   string(3) "Red"
//   [1]=>
//   string(4) "Gold"
// }
```
En el mundo m√°gico de Hogwarts, cada casa tiene sus colores. En nuestro ejemplo anterior, hemos a√±adido un `getHouseColor()` m√©todo a nuestra *House* enumeraci√≥n para devolver el color de cada casa.

Cuando se define un m√©todo dentro de una enumeraci√≥n, la `$this` variable se define y hace referencia a la instancia del caso.

### Los Enumerados puden usar Traits e implementar interfaces

Al igual que las clases, las enumeraciones pueden usar `traits`. Esto es genial cuando hay muchos m√©todos y necesitas dividirlos en varios archivos para mantener el c√≥digo m√°s ordenado.

Sin embargo, existen algunas restricciones:

- No puedes tener propiedades.
- No puedes anular los m√©todos de enumeraciones (como `values()`).

```php	
trait Colors
{
    public function getHouseColors() : array
    {
        return match($this) {
            House::Gryffindor => ['Red', 'Gold'],
            House::Hufflepuff => ['Yellow', 'Black'],
            House::Ravenclaw => ['Blue', 'Bronze'],
            House::Slytherin => ['Green', 'Silver'],
        };
    }
}

enum House
{
    use Colors;
  
    case Gryffindor;
    case Hufflepuff;
    case Ravenclaw;
    case Slytherin;
}
```

Al igual que los `Traits` en las clases, las interfaces tambi√©n se pueden implementar en enumeraciones. Es dif√≠cil encontrar un ejemplo concreto para este caso de uso, pero aqu√≠ lo tienes de todos modos:

```php	
interface HasColors
{
    public function getHouseColors() : array;
}

enum House implements HasColors
{
    case Gryffindor;
    case Hufflepuff;
    case Ravenclaw;
    case Slytherin;
  
    public function getHouseColors() : array
    {
        return match($this) {
            House::Gryffindor => ['Red', 'Gold'],
            House::Hufflepuff => ['Yellow', 'Black'],
            House::Ravenclaw => ['Blue', 'Bronze'],
            House::Slytherin => ['Green', 'Silver'],
        };
    }
}
``` 

### ¬øQu√© pasa con las enumeraciones en PHP 7 e incluso en versiones anteriores?

Antes de la introducci√≥n de las enumeraciones nativas en PHP 8.1, las enumeraciones se manejaban en PHP de diferentes maneras, ninguna de las cuales era particularmente elegante o confiable. Estas son algunas de las estrategias m√°s comunes:

- **Constantes de clase**: quiz√°s la forma m√°s com√∫n de implementar enumeraciones fue mediante constantes de clase. A continuaci√≥n, se muestra un ejemplo:
    ```php	
    class House
    {
        const Gryffindor = 'Gryffindor';
        const Hufflepuff = 'Hufflepuff';
        const Ravenclaw = 'Ravenclaw';
        const Slytherin = 'Slytherin';
    }
    ```

    De esta manera, podr√≠as hacer referencia a un valor de enumeraci√≥n con House::Gryffindor, por ejemplo. Este enfoque proporciona una forma de agrupar constantes relacionadas, pero no proporciona ninguna de las funciones o seguridad de tipos que las enumeraciones verdaderas podr√≠an ofrecer (porque las constantes de clase no se pueden tipificar y marcar como de solo lectura).


- **Matrices**: otra forma com√∫n de implementar enumeraciones fue mediante matrices. 
    ```php
    $houses = [
        'Gryffindor',
        'Hufflepuff',
        'Ravenclaw',
        'Slytherin',
    ];
    ```
    Sin embargo, este m√©todo tambi√©n carece de los beneficios de las enumeraciones verdaderas, como la seguridad de tipos y el autocompletado.

- **SplEnum** : PHP sol√≠a tener una clase SplEnum incorporada, que formaba parte de la biblioteca est√°ndar de PHP (SPL). Sin embargo, no se adopt√≥ ampliamente debido a sus problemas de rendimiento y requer√≠a la extensi√≥n SPL Types, que no ven√≠a incluida con PHP y se consideraba experimental.
    ```php	
    class House extends SplEnum
    {
        const Gryffindor = 'Gryffindor';
        const Hufflepuff = 'Hufflepuff';
        const Ravenclaw = 'Ravenclaw';
        const Slytherin = 'Slytherin';
    }
    ```
    Esta clase se elimin√≥ en PHP 7.0, por lo que ya no se utiliza.

- **Paquetes de terceros**: tambi√©n hay varios paquetes que proporcionan funcionalidad de enumeraci√≥n, como myclabs/php-enum . Estos suelen proporcionar m√°s funciones que las constantes de clase o matrices simples, como m√©todos para enumerar todos los valores posibles, convertir a/desde cadenas, etc.
    ```php
    use MyCLabs\Enum\Enum;

    class House extends Enum
    {
        const Gryffindor = 'Gryffindor';
        const Hufflepuff = 'Hufflepuff';
        const Ravenclaw = 'Ravenclaw';
        const Slytherin = 'Slytherin';
    }
    ```

A pesar de estas soluciones alternativas, ninguna de ellas podr√≠a proporcionar el conjunto completo de caracter√≠sticas que las enumeraciones verdaderas pueden ofrecer, como seguridad de tipos, optimizaci√≥n del rendimiento y funcionalidad como obtener todos los valores posibles.

Es por esto que la incorporaci√≥n de enumeraciones nativas en PHP 8.1 fue una mejora tan importante para el lenguaje.
