# PHP Avanzado

### Programación orientada a objetos

Este punto se estudia en el siguiente tema, aunque por motivos de temática, se incluye aquí porque es un concepto avanzado de PHP.

[Programación orientada a objetos en PHP](03phpoo.md)


## Nuevas carácterísticas de PHP 8

Desde su lanzamiento a fines de 2020, PHP 8 ha sido un punto de inflexión. En este tutorial, repasaré todas las funciones más recientes con ejemplos reales de cuándo podría optar por usarlas.

Me enamoré del lenguaje PHP al principio de mi carrera y, desde entonces, lo he defendido como lenguaje cada vez que he tenido la oportunidad. Sin embargo, desde el lanzamiento de la versión 8.*, no he tenido que exagerar ni un solo detalle. En cambio, he podido confiar únicamente en los hechos con el lenguaje. Echemos un vistazo a algunas de las características destacadas de la versión 8.0 de PHP.

### Promoción de pripiedades en constructores

Esta debe ser una de las funciones más útiles de la versión 8.0 y que más tiempo y pulsaciones de techa puede ahorrar. Vamos a desglosarla:

=== "Antes..."
    ```php
    class Cliente
    {
        private $url;
 
        public function __construct($url)
        {
            $this->url = $url;
        }
    }
    ```

=== "PHP 8.0"
    ``` php
    class Client
    {
        public function __construct(
            private string $url,
        ) {}
    }
    ```
Ahora podemos establecer propiedades en nuestros objetos directamente en el constructor como argumento en lugar de tener que asignarlas manualmente. Ahora utilizo esta función casi todo el tiempo, ya que ahorra esfuerzo, pero también mantiene las propiedades contenidas en el constructor, por lo que comprendes mucho más sobre tus objetos de inmediato, sin necesidad de desplazarte por la pantalla.


### Union Types

Otra característica fantástica que se lanzó son los tipos de unión. Aquí es donde una variable con sugerencia de tipo o un tipo de retorno puede ser uno o más tipos. Esto ha ayudado con el análisis estático, donde puede haber retornos condicionales dentro de un método. Veamos un ejemplo.

=== "Antes..."
    ```php
    class PostService
    {
        public function all(): mixed
        {
            if (! Auth::check()) {
                return [];
            }
    
            return Post::query()->get();
        }
    }
    ```

=== "PHP 8.0"
    ``` php
    class PostService
    {
        public function all(): array|Collection
        {
            if (! Auth::check()) {
                return [];
            }
    
            return Post::query()->get();
        }
    }
    ```	

### Argumentos con nombre

Esta es una característica que he estado esperando durante mucho tiempo. Ahora, en lugar de tener que recordar el orden de los argumentos de un método, puedes pasarlos por nombre. Esto es especialmente útil cuando tienes métodos con muchos argumentos y solo necesitas pasar uno o dos.

=== "Antes ..."
    ```php
    class ProcessImage
    {
        public static function handle(string $path, int $height, int $width, string $type, int $quality, int $compression): void
        {
            // logic for handling image processing
        }
    }
    
    ProcessImage::handle('/path/to/image.jpg', 500, 300, 'jpg', 100, 5);
    ```

=== "PHP 8.0"
    ```php
    class ProcessImage
    {
        public static function handle(string $path, int $height, int $width, string $type, int $quality, int $compression): void
        {
            // logic for handling image processing
        }
    }
    
    ProcessImage::handle(
        path: '/path/to/image.jpg',
        height: 500,
        width: 300,
        type: 'jpg',
        quality: 100,
        compression: 5,
    );
    ```
Como puede ver en el ejemplo anterior, si se colocan la altura y el ancho de forma incorrecta, se generarían efectos diferentes a los que podría esperar. Dado que la clase y la implementación están una al lado de la otra, es relativamente fácil. Ahora imagine que este método proviene de un paquete que instaló y que puede no tener la mejor documentación: el uso de argumentos con nombre le permite a usted y a cualquier otra persona que use su base de código comprender el orden de estos argumentos para el método. Sin embargo, esto debe usarse con precaución, ya que los autores de bibliotecas tienden a cambiar los nombres de los parámetros con mayor frecuencia y no siempre se consideran cambios importantes.

### Expresiones con match

La expresión `match` es una versión más segura y concisa de la declaración `switch`. En PHP 8.0, se introdujeron expresiones en `match`, que permiten la asignación de variables en la expresión `match`. Veamos un ejemplo.

=== "Antes ..."
    ```php
    switch (string $method) {
        case 'GET':
            $method = 'GET';
            break;
        case 'POST':
            $method = 'POST';
            break;
        default:
            throw new Exception("$method is not supported yet.");
    }
    ```

=== "PHP 8.0"
    ```php
    match (string $method) {
        'GET' => $method = 'GET',
        'POST' => $method = 'POST',
        default => throw new Exception(
            message: "$method is not supported yet.",
        ),
    };
    ```

??? example "Ejemplos más avanzados con `match`"

    La expresión `match` es más concisa y segura que la declaración `switch`. Además, las expresiones en `match` permiten la asignación de variables en la expresión `match`, lo que hace que el código sea más limpio y fácil de leer.

    Otros ejemplos con `match`:

    ```php
    // Before PHP 8.0
    switch ($status) {
        case 'active':
            $message = 'User is active';
            break;
        case 'inactive':
            $message = 'User is inactive';
            break;
        default:
            $message = 'User status is unknown';
    }
    ```

    ```php
    // PHP 8.0
    $message = match ($status) {
        'active' => 'User is active',
        'inactive' => 'User is inactive',
        default => 'User status is unknown',
    };
    ```

    `match` también puede comparar rangos de valores:

    ```php
    // Before PHP 8.0
    switch ($age) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
            $group = 'Toddler';
            break;
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
            $group = 'Child';
            break;
        default:
            $group = 'Unknown';
    }
    ```

    ```php
    // PHP 8.0
    $group = match ($age) {
        0, 1, 2, 3, 4 => 'Toddler',
        5, 6, 7, 8, 9 => 'Child',
        default => 'Unknown',
    };

    # o también

    $group = match (true) {
        $age >= 0 && $age <= 4 => 'Toddler',
        $age >= 5 && $age <= 9 => 'Child',
        default => 'Unknown',
    };
    ```

    También es posible usar expresiones complejas en `match`:

    ```php
    $count = get_count();
    $size = match(true) {
        $count > 0 && $count <=10 => 'small',
        $count <=50 => 'medium',
        $count >50 => 'huge',
    };
    ```

    También con expresiones regulares:

    ```php
    // PHP 8.0
    $message = match (true) {
        preg_match('/^foo/', $string) => 'String starts with foo',
        preg_match('/bar$/', $string) => 'String ends with bar',
        default => 'String does not start with foo or end with bar',
    };
    ```

### Uso de ::class en objetos

En el pasado, cuando querías pasar una cadena de clase a un método, tenías que usar algo como get_class, lo que siempre parecía un poco inútil. El sistema ya sabe sobre la clase en ese momento, ya que ya la has cargado automáticamente o has creado una nueva instancia. Veamos un ejemplo:

=== "Antes..."
    ```php
    // Before PHP 8.0
    $commandBus->dispatch(get_class($event), $payload);
    ```

=== "PHP 8.0"
    ```php
    $commandBus->dispatch(
        event: $event::class,
        payload: $payload,
    );
    ```

Puede que no sea un dispositivo espectacular en términos de características, pero definitivamente es algo que uso y a lo que siempre recurriré cuando lo necesite.

### Nullsafe Operator

El operador nullsafe es una de las características más esperadas de PHP 8.0. Este operador permite acceder a propiedades y métodos de un objeto que puede ser nulo sin generar un error. Veamos un ejemplo.

=== "Antes de PHP 8.0"
    ```php
    // Before PHP 8.0
    if ($user !== null) {
        $address = $user->getAddress();
        if ($address !== null) {
            $city = $address->getCity();
            if ($city !== null) {
                $cityName = $city->getName();
            }
        }
    }
    ```

=== "PHP 8.0"
    ```php
    $cityName = $user?->getAddress()?->getCity()?->getName();
    ```

### Bloques try/catch sin excepción

En PHP 8.0, ahora puedes usar bloques try/catch sin excepción. Esto es útil cuando no necesitas la excepción en sí, sino que solo necesitas manejar el error. Veamos un ejemplo.

=== "Antes de PHP 8.0"
    ```php
    try {
        $response = $this->sendRequest();
    } catch (RequestException $exception) {
        Log::error('API request failed to send.');
    }
    ```

=== "PHP 8.0"
    ```php
    try {
        $response = $this->sendRequest();
    } catch (RequestException) {
        Log::error('API request failed to send.');
    }
    ```

### Enumeraciones

Las enumeraciones son una forma de definir un conjunto de constantes con nombre. En PHP 8.1, se introdujeron las enumeraciones. Veamos un ejemplo.

=== "PHP 8.0"
    ```php
    class Method
    {
        public const GET = 'GET';
        public const POST = 'POST';
        public const PUT = 'PUT';
        public const PATCH = 'PATCH';
        public const DELETE = 'DELETE';
    }
    ```

=== "PHP 8.1"
    ```php
    enum Method {
        case GET;
        case POST;
        case PUT;
        case PATCH;
        case DELETE;
    }
    ```

El ejemplo anterior resalta las diferencias de sintaxis, que se han mejorado, pero ¿qué sucede con el uso real? Tomemos un ejemplo rápido de una característica que normalmente utilizaría en una integración de API.

=== "Antes de PHP 8.1"
    ```php
    trait SendsRequests
    {
        public function send(string $method, string $uri, array $options = []): Response
        {
            if (! in_array($method, ['GET', 'POST', 'PATCH', 'PUT', 'DELETE'])) {
                throw new InvalidArgumentException(
                    message: "Method [$method] is not supported.",
                );
            }
    
            return $this->buildRequest()->send(
                method: $method,
                uri: $uri,
                options: $options,
            );
        }
    }
    ```

=== "PHP 8.1"
    ```php
    trait SendsRequests
    {
        public function send(Method $method, string $uri, array $options = []): Response
        {
            return $this->buildRequest()->send(
                method: $method->value,
                uri: $uri,
                options: $options,
            );
        }
    }
    ```

Otro ejemplo de uso de enumeraciones sería en la validación de datos.

=== "Antes..."
    ```php
    public function validate(string $method): void
    {
        if (! in_array($method, ['GET', 'POST', 'PATCH', 'PUT', 'DELETE'])) {
            throw new InvalidArgumentException(
                message: "Method [$method] is not supported.",
            );
        }
    }
    ```

=== "PHP 8.1"
    ```php
    public function validate(Method $method): void
    {
        // No need to validate the method here
    }
    ```

### Unpacking Arrays

En PHP 8.1, se introdujo la capacidad de desempaquetar matrices. Esto es útil cuando necesita pasar una matriz a un método que acepta argumentos de forma individual. Veamos un ejemplo.

=== "Antes..."
    ```php
    $this->sendRequest($data['method'], $data['uri'], $data['options']);
    ```

=== "PHP 8.1"
    ```php
    $this->sendRequest(...$data);
    ```
En el ejemplo anterior, `$data` es una matriz que contiene los argumentos que se pasan al método `sendRequest`. En lugar de pasar cada elemento de la matriz individualmente, puede desempaquetar la matriz con `...` y pasarla al método.


### Propiedades de solo lectura

En PHP 8.1, se introdujeron las propiedades de solo lectura. Esto le permite definir propiedades que solo se pueden establecer una vez y no se pueden modificar después de la inicialización. Veamos un ejemplo.

=== "PHP 8.0"
    ```php
    class User
    {
        public string $name;
    
        public function __construct(string $name)
        {
            $this->name = $name;
        }
    }
    ```

=== "PHP 8.1"
    ```php
    class User
    {
        public readonly string $name;
    
        public function __construct(string $name)
        {
            $this->name = $name;
        }
    }
    ```

En el ejemplo anterior, la propiedad `$name` se declara como `readonly`, lo que significa que solo se puede establecer una vez en el constructor y no se puede modificar después de la inicialización.

Este tipo de característica permite programa en inmutabilidad, lo que puede hacer que su código sea más seguro sin tener que reducir la visibilidad de las propiedades. Antes teniamos que cambiar las propiedades que quería que fueran públicas y que estuvieran protegidas o privadas, lo que significaba que luego teníamos que agregar `getters` a la clase, lo que parecía como agregar código repetitivo que realmente no era necesario. 

Un ejemplo de esto sería una clase de entidad que tiene propiedades que no deberían cambiar después de la inicialización.

=== "PHP 8.0"
    ```php
    class Post
    {
        public function __construct() {
            protected string $title,
            protected string $content,
        }
    
        public function getTitle(): string
        {
            return $this->title;
        }
    
        public function getContent(): string
        {
            return $this->content;
        }
    }
    ```

=== "PHP 8.1"
    ```php
    class Post
    {
        public function __construct() {
            public readonly string $title,
            public readonly string $content,
        }
    }
    ```